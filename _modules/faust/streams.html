
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>faust.streams &#8212; Faust 0.2.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for faust.streams</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Streams.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">reprlib</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">asyncio</span> <span class="k">import</span> <span class="n">CancelledError</span>
<span class="kn">from</span> <span class="nn">contextvars</span> <span class="k">import</span> <span class="n">ContextVar</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">AsyncIterable</span><span class="p">,</span>
    <span class="n">AsyncIterator</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">MutableSequence</span><span class="p">,</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">mode</span> <span class="k">import</span> <span class="n">Seconds</span><span class="p">,</span> <span class="n">Service</span><span class="p">,</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">shortlabel</span><span class="p">,</span> <span class="n">want_seconds</span>
<span class="kn">from</span> <span class="nn">mode.utils.aiter</span> <span class="k">import</span> <span class="n">aenumerate</span><span class="p">,</span> <span class="n">aiter</span>
<span class="kn">from</span> <span class="nn">mode.utils.futures</span> <span class="k">import</span> <span class="n">current_task</span><span class="p">,</span> <span class="n">maybe_async</span><span class="p">,</span> <span class="n">notify</span>
<span class="kn">from</span> <span class="nn">mode.utils.queues</span> <span class="k">import</span> <span class="n">ThrowableQueue</span>
<span class="kn">from</span> <span class="nn">mode.utils.types.trees</span> <span class="k">import</span> <span class="n">NodeT</span>
<span class="kn">from</span> <span class="nn">mode.utils.typing</span> <span class="k">import</span> <span class="n">Deque</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">joins</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="k">import</span> <span class="n">ImproperlyConfigured</span><span class="p">,</span> <span class="n">Skip</span>
<span class="kn">from</span> <span class="nn">.types</span> <span class="k">import</span> <span class="n">TP</span><span class="p">,</span> <span class="n">AppT</span><span class="p">,</span> <span class="n">ConsumerT</span><span class="p">,</span> <span class="n">EventT</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">ModelArg</span><span class="p">,</span> <span class="n">ModelT</span><span class="p">,</span> <span class="n">TopicT</span>
<span class="kn">from</span> <span class="nn">.types.joins</span> <span class="k">import</span> <span class="n">JoinT</span>
<span class="kn">from</span> <span class="nn">.types.models</span> <span class="k">import</span> <span class="n">FieldDescriptorT</span>
<span class="kn">from</span> <span class="nn">.types.serializers</span> <span class="k">import</span> <span class="n">SchemaT</span>
<span class="kn">from</span> <span class="nn">.types.streams</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">GroupByKeyArg</span><span class="p">,</span>
    <span class="n">JoinableT</span><span class="p">,</span>
    <span class="n">Processor</span><span class="p">,</span>
    <span class="n">StreamT</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">T_co</span><span class="p">,</span>
    <span class="n">T_contra</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.types.topics</span> <span class="k">import</span> <span class="n">ChannelT</span>
<span class="kn">from</span> <span class="nn">.types.tuples</span> <span class="k">import</span> <span class="n">Message</span>

<span class="n">NO_CYTHON</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NO_CYTHON&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">NO_CYTHON</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">._cython.streams</span> <span class="k">import</span> <span class="n">StreamIterator</span> <span class="k">as</span> <span class="n">_CStreamIterator</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">_CStreamIterator</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">_CStreamIterator</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Stream&quot;</span><span class="p">,</span>
    <span class="s2">&quot;current_event&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">_current_event</span><span class="p">:</span> <span class="n">ContextVar</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">weakref</span><span class="o">.</span><span class="n">ReferenceType</span><span class="p">[</span><span class="n">EventT</span><span class="p">]]]</span>
<span class="n">_current_event</span> <span class="o">=</span> <span class="n">ContextVar</span><span class="p">(</span><span class="s2">&quot;current_event&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="current_event"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.current_event">[docs]</a><span class="k">def</span> <span class="nf">current_event</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EventT</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Return the event currently being processed, or None.&quot;&quot;&quot;</span>
    <span class="n">eventref</span> <span class="o">=</span> <span class="n">_current_event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eventref</span><span class="p">()</span> <span class="k">if</span> <span class="n">eventref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>


<span class="k">async</span> <span class="k">def</span> <span class="nf">maybe_forward</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">EventT</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">value</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="k">class</span> <span class="nc">_LinkedListDirection</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">getter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">StreamT</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]]</span>


<span class="n">_LinkedListDirectionFwd</span> <span class="o">=</span> <span class="n">_LinkedListDirection</span><span class="p">(</span><span class="s2">&quot;_next&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">_next</span><span class="p">)</span>
<span class="n">_LinkedListDirectionBwd</span> <span class="o">=</span> <span class="n">_LinkedListDirection</span><span class="p">(</span><span class="s2">&quot;_prev&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">_prev</span><span class="p">)</span>


<div class="viewcode-block" id="Stream"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream">[docs]</a><span class="k">class</span> <span class="nc">Stream</span><span class="p">(</span><span class="n">StreamT</span><span class="p">[</span><span class="n">T_co</span><span class="p">],</span> <span class="n">Service</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A stream: async iterator processing events in channels/topics.&quot;&quot;&quot;</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
    <span class="c1"># Service starting/stopping logs use severity DEBUG in this class.</span>
    <span class="n">mundane_level</span> <span class="o">=</span> <span class="s2">&quot;debug&quot;</span>

    <span class="c1">#: Number of events processed by this instance so far.</span>
    <span class="n">events_total</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">_processors</span><span class="p">:</span> <span class="n">MutableSequence</span><span class="p">[</span><span class="n">Processor</span><span class="p">]</span>
    <span class="n">_anext_started</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_passive</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_passive_started</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">channel</span><span class="p">:</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T_co</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">app</span><span class="p">:</span> <span class="n">AppT</span><span class="p">,</span>
        <span class="n">processors</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Processor</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">combined</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">JoinableT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">on_start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">join_strategy</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">JoinT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">beacon</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">NodeT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">concurrency_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prev</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">active_partitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">TP</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">enable_acks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">loop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">AbstractEventLoop</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Service</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">,</span> <span class="n">beacon</span><span class="o">=</span><span class="n">beacon</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">app</span> <span class="o">=</span> <span class="n">app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">FlowControlQueue</span><span class="p">(</span>
            <span class="n">maxsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">stream_buffer_maxsize</span><span class="p">,</span>
            <span class="n">clear_on_resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_passive_started</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join_strategy</span> <span class="o">=</span> <span class="n">join_strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span> <span class="k">if</span> <span class="n">combined</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concurrency_index</span> <span class="o">=</span> <span class="n">concurrency_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span> <span class="o">=</span> <span class="n">prev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active_partitions</span> <span class="o">=</span> <span class="n">active_partitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="n">enable_acks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">processors</span><span class="p">)</span> <span class="k">if</span> <span class="n">processors</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_start</span> <span class="o">=</span> <span class="n">on_start</span>

        <span class="c1"># attach beacon to channel, or if iterable attach to current task.</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">current_task</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">task_owner</span> <span class="o">=</span> <span class="n">task</span>

        <span class="c1"># Generate message handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_stream_event_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">on_stream_event_in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_stream_event_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">on_stream_event_out</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_message_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">on_message_in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_message_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">sensors</span><span class="o">.</span><span class="n">on_message_out</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_skipped_value</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<div class="viewcode-block" id="Stream.get_active_stream"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.get_active_stream">[docs]</a>    <span class="k">def</span> <span class="nf">get_active_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return the currently active stream.</span>

<span class="sd">        A stream can be derived using ``Stream.group_by`` etc,</span>
<span class="sd">        so if this stream was used to create another derived</span>
<span class="sd">        stream, this function will return the stream being actively</span>
<span class="sd">        consumed from.  E.g. in the example::</span>

<span class="sd">            &gt;&gt;&gt; @app.agent()</span>
<span class="sd">            ... async def agent(a):</span>
<span class="sd">            ..      a = a</span>
<span class="sd">            ...     b = a.group_by(Withdrawal.account_id)</span>
<span class="sd">            ...     c = b.through(&#39;backup_topic&#39;)</span>
<span class="sd">            ...     async for value in c:</span>
<span class="sd">            ...         ...</span>

<span class="sd">        The return value of ``a.get_active_stream()`` would be ``c``.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The chain of streams that leads to the active stream</span>
<span class="sd">            is decided by the :attr:`_next` attribute. To get</span>
<span class="sd">            to the active stream we just traverse this linked-list::</span>

<span class="sd">                &gt;&gt;&gt; def get_active_stream(self):</span>
<span class="sd">                ...     node = self</span>
<span class="sd">                ...     while node._next:</span>
<span class="sd">                ...         node = node._next</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_ll_forwards</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stream.get_root_stream"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.get_root_stream">[docs]</a>    <span class="k">def</span> <span class="nf">get_root_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the root stream that this stream was derived from.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_ll_backwards</span><span class="p">())[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_iter_ll_forwards</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_ll</span><span class="p">(</span><span class="n">_LinkedListDirectionFwd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_ll_backwards</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_ll</span><span class="p">(</span><span class="n">_LinkedListDirectionBwd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_</span><span class="p">:</span> <span class="n">_LinkedListDirection</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]:</span>
        <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">seen</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">StreamT</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Loop in Stream.</span><span class="si">{dir_.attr}</span><span class="s2">: Call support!&quot;</span><span class="p">)</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">dir_</span><span class="o">.</span><span class="n">getter</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<div class="viewcode-block" id="Stream.add_processor"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.add_processor">[docs]</a>    <span class="k">def</span> <span class="nf">add_processor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processor</span><span class="p">:</span> <span class="n">Processor</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add processor callback executed whenever a new event is received.</span>

<span class="sd">        Processor functions can be async or non-async, must accept</span>
<span class="sd">        a single argument, and should return the value, mutated or not.</span>

<span class="sd">        For example a processor handling a stream of numbers may modify</span>
<span class="sd">        the value::</span>

<span class="sd">            def double(value: int) -&gt; int:</span>
<span class="sd">                return value * 2</span>

<span class="sd">            stream.add_processor(double)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processor</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.info"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return stream settings as a dictionary.&quot;&quot;&quot;</span>
        <span class="c1"># used by e.g. .clone to reconstruct keyword arguments</span>
        <span class="c1"># needed to create a clone of the stream.</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;app&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="p">,</span>
            <span class="s2">&quot;channel&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span>
            <span class="s2">&quot;processors&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="p">,</span>
            <span class="s2">&quot;on_start&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_start</span><span class="p">,</span>
            <span class="s2">&quot;loop&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="p">,</span>
            <span class="s2">&quot;combined&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">,</span>
            <span class="s2">&quot;beacon&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beacon</span><span class="p">,</span>
            <span class="s2">&quot;concurrency_index&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">concurrency_index</span><span class="p">,</span>
            <span class="s2">&quot;prev&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prev</span><span class="p">,</span>
            <span class="s2">&quot;active_partitions&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_partitions</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Stream.clone"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.clone">[docs]</a>    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create a clone of this stream.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If the cloned stream is supposed to supersede this stream,</span>
<span class="sd">            like in ``group_by``/``through``/etc., you should use</span>
<span class="sd">            :meth:`_chain` instead so `stream._next = cloned_stream`</span>
<span class="sd">            is set and :meth:`get_active_stream` returns the cloned stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">new_stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">on_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maybe_start</span><span class="p">,</span>
            <span class="n">prev</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="c1"># move processors to active stream</span>
            <span class="n">processors</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="p">),</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># delete moved processors from self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new_stream</span>

<div class="viewcode-block" id="Stream.noack"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.noack">[docs]</a>    <span class="k">def</span> <span class="nf">noack</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;StreamT&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create new stream where acks are manual.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="n">new_stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span>
            <span class="n">enable_acks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_stream</span></div>

<div class="viewcode-block" id="Stream.items"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.items">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">K</span><span class="p">,</span> <span class="n">T_co</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the stream as ``key, value`` pairs.</span>

<span class="sd">        Examples:</span>
<span class="sd">            .. sourcecode:: python</span>

<span class="sd">                @app.agent(topic)</span>
<span class="sd">                async def mytask(stream):</span>
<span class="sd">                    async for key, value in stream.items():</span>
<span class="sd">                        print(key, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">cast</span><span class="p">(</span><span class="n">T_co</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.events"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.events">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">EventT</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterate over the stream as events exclusively.</span>

<span class="sd">        This means the stream must be iterating over a channel,</span>
<span class="sd">        or at least an iterable of event objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># noqa: F841</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span></div>

<div class="viewcode-block" id="Stream.take"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.take">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">within</span><span class="p">:</span> <span class="n">Seconds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">T_co</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Buffer n values at a time and yield a list of buffered values.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            max_: Max number of messages to receive. When more than this</span>
<span class="sd">                number of messages are received within the specified number of</span>
<span class="sd">                seconds then we flush the buffer immediately.</span>
<span class="sd">            within: Timeout for when we give up waiting for another value,</span>
<span class="sd">                and process the values we have.</span>
<span class="sd">                Warning: If there&#39;s no timeout (i.e. `timeout=None`),</span>
<span class="sd">                the agent is likely to stall and block buffered events for an</span>
<span class="sd">                unreasonable length of time(!).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T_co</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EventT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">buffer_add</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">append</span>
        <span class="n">event_add</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">append</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="fm">__len__</span>
        <span class="n">buffer_full</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">buffer_consumed</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">want_seconds</span><span class="p">(</span><span class="n">within</span><span class="p">)</span> <span class="k">if</span> <span class="n">within</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">stream_enable_acks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span>

        <span class="n">buffer_consuming</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">channel_it</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># We add this processor to populate the buffer, and the stream</span>
        <span class="c1"># is passively consumed in the background (enable_passive below).</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">add_to_buffer</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># buffer_consuming is set when consuming buffer after timeout.</span>
                <span class="k">nonlocal</span> <span class="n">buffer_consuming</span>
                <span class="k">if</span> <span class="n">buffer_consuming</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">await</span> <span class="n">buffer_consuming</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">buffer_add</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">T_co</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span>
                <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Take buffer found current_event is None&quot;</span><span class="p">)</span>
                <span class="n">event_add</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer_size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">max_</span><span class="p">:</span>
                    <span class="c1"># signal that the buffer is full and should be emptied.</span>
                    <span class="n">buffer_full</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                    <span class="c1"># strict wait for buffer to be consumed after buffer full.</span>
                    <span class="c1"># If max is 1000, we are not allowed to return 1001 values.</span>
                    <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">buffer_consumed</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error adding to take buffer: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">crash</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># Disable acks to ensure this method acks manually</span>
        <span class="c1"># events only after they are consumed by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_passive</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="n">channel_it</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_stop</span><span class="p">:</span>
                <span class="c1"># wait until buffer full, or timeout</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_stopped</span><span class="p">(</span><span class="n">buffer_full</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                    <span class="c1"># make sure background thread does not add new items to</span>
                    <span class="c1"># buffer while we read.</span>
                    <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="nb">list</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
                            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">ack</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                        <span class="n">events</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="c1"># allow writing to buffer again</span>
                        <span class="n">notify</span><span class="p">(</span><span class="n">buffer_consuming</span><span class="p">)</span>
                        <span class="n">buffer_full</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">pass</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Restore last behaviour of &quot;enable_acks&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="n">stream_enable_acks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.take_with_timestamp"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.take_with_timestamp">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">take_with_timestamp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">within</span><span class="p">:</span> <span class="n">Seconds</span><span class="p">,</span> <span class="n">timestamp_field_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">T_co</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Buffer n values at a time and yield a list of buffered values with the</span>
<span class="sd">           timestamp when the message was added to kafka.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            max_: Max number of messages to receive. When more than this</span>
<span class="sd">                number of messages are received within the specified number of</span>
<span class="sd">                seconds then we flush the buffer immediately.</span>
<span class="sd">            within: Timeout for when we give up waiting for another value,</span>
<span class="sd">                and process the values we have.</span>
<span class="sd">                Warning: If there&#39;s no timeout (i.e. `timeout=None`),</span>
<span class="sd">                the agent is likely to stall and block buffered events for an</span>
<span class="sd">                unreasonable length of time(!).</span>
<span class="sd">            timestamp_field_name: the name of the field containing kafka timestamp,</span>
<span class="sd">                that is going to be added to the value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T_co</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EventT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">buffer_add</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">append</span>
        <span class="n">event_add</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">append</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="fm">__len__</span>
        <span class="n">buffer_full</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">buffer_consumed</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">want_seconds</span><span class="p">(</span><span class="n">within</span><span class="p">)</span> <span class="k">if</span> <span class="n">within</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">stream_enable_acks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span>

        <span class="n">buffer_consuming</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">channel_it</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># We add this processor to populate the buffer, and the stream</span>
        <span class="c1"># is passively consumed in the background (enable_passive below).</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">add_to_buffer</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># buffer_consuming is set when consuming buffer after timeout.</span>
                <span class="k">nonlocal</span> <span class="n">buffer_consuming</span>
                <span class="k">if</span> <span class="n">buffer_consuming</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">await</span> <span class="n">buffer_consuming</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">timestamp_field_name</span><span class="p">:</span>
                    <span class="n">value</span><span class="p">[</span><span class="n">timestamp_field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">timestamp</span>
                <span class="n">buffer_add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Take buffer found current_event is None&quot;</span><span class="p">)</span>
                <span class="n">event_add</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer_size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">max_</span><span class="p">:</span>
                    <span class="c1"># signal that the buffer is full and should be emptied.</span>
                    <span class="n">buffer_full</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                    <span class="c1"># strict wait for buffer to be consumed after buffer full.</span>
                    <span class="c1"># If max is 1000, we are not allowed to return 1001 values.</span>
                    <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">buffer_consumed</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error adding to take buffer: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">crash</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># Disable acks to ensure this method acks manually</span>
        <span class="c1"># events only after they are consumed by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_passive</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="n">channel_it</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_stop</span><span class="p">:</span>
                <span class="c1"># wait until buffer full, or timeout</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_stopped</span><span class="p">(</span><span class="n">buffer_full</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                    <span class="c1"># make sure background thread does not add new items to</span>
                    <span class="c1"># buffer while we read.</span>
                    <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="nb">list</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
                            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">ack</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                        <span class="n">events</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="c1"># allow writing to buffer again</span>
                        <span class="n">notify</span><span class="p">(</span><span class="n">buffer_consuming</span><span class="p">)</span>
                        <span class="n">buffer_full</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">pass</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Restore last behaviour of &quot;enable_acks&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="n">stream_enable_acks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.enumerate"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.enumerate">[docs]</a>    <span class="k">def</span> <span class="nf">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">T_co</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Enumerate values received on this stream.</span>

<span class="sd">        Unlike Python&#39;s built-in ``enumerate``, this works with</span>
<span class="sd">        async generators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">aenumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.noack_take"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.noack_take">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">noack_take</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">max_</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">within</span><span class="p">:</span> <span class="n">Seconds</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">T_co</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Buffer n values at a time and yield a list of buffered values.</span>
<span class="sd">        :param max_: Max number of messages to receive. When more than this</span>
<span class="sd">             number of messages are received within the specified number of</span>
<span class="sd">             seconds then we flush the buffer immediately.</span>
<span class="sd">        :param within: Timeout for when we give up waiting for another value,</span>
<span class="sd">             and process the values we have.</span>
<span class="sd">             Warning: If there&#39;s no timeout (i.e. `timeout=None`),</span>
<span class="sd">             the agent is likely to stall and block buffered events for an</span>
<span class="sd">             unreasonable length of time(!).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T_co</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">events</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">EventT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">buffer_add</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">append</span>
        <span class="n">event_add</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">append</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="fm">__len__</span>
        <span class="n">buffer_full</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">buffer_consumed</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="n">want_seconds</span><span class="p">(</span><span class="n">within</span><span class="p">)</span> <span class="k">if</span> <span class="n">within</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">stream_enable_acks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span>

        <span class="n">buffer_consuming</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">channel_it</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># We add this processor to populate the buffer, and the stream</span>
        <span class="c1"># is passively consumed in the background (enable_passive below).</span>
        <span class="k">async</span> <span class="k">def</span> <span class="nf">add_to_buffer</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># buffer_consuming is set when consuming buffer</span>
                <span class="c1"># after timeout.</span>
                <span class="k">nonlocal</span> <span class="n">buffer_consuming</span>
                <span class="k">if</span> <span class="n">buffer_consuming</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">await</span> <span class="n">buffer_consuming</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># We want to save events instead of values to allow for manual ack</span>
                <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span>
                <span class="n">buffer_add</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">T_co</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Take buffer found current_event is None&quot;</span><span class="p">)</span>

                <span class="n">event_add</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer_size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">max_</span><span class="p">:</span>
                    <span class="c1"># signal that the buffer is full and should be emptied.</span>
                    <span class="n">buffer_full</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                    <span class="c1"># strict wait for buffer to be consumed after buffer</span>
                    <span class="c1"># full.</span>
                    <span class="c1"># If max is 1000, we are not allowed to return 1001</span>
                    <span class="c1"># values.</span>
                    <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">buffer_consumed</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">CancelledError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error adding to take buffer: </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">crash</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c1"># Disable acks to ensure this method acks manually</span>
        <span class="c1"># events only after they are consumed by the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_passive</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="n">channel_it</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_stop</span><span class="p">:</span>
                <span class="c1"># wait until buffer full, or timeout</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_stopped</span><span class="p">(</span><span class="n">buffer_full</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                    <span class="c1"># make sure background thread does not add new items to</span>
                    <span class="c1"># buffer while we read.</span>
                    <span class="n">buffer_consuming</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="nb">list</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="c1"># code change: We want to manually ack</span>
                        <span class="c1"># for event in events:</span>
                        <span class="c1">#     await self.ack(event)</span>
                        <span class="n">events</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="c1"># allow writing to buffer again</span>
                        <span class="n">notify</span><span class="p">(</span><span class="n">buffer_consuming</span><span class="p">)</span>
                        <span class="n">buffer_full</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="n">buffer_consumed</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                <span class="k">pass</span>

        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Restore last behaviour of &quot;enable_acks&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span> <span class="o">=</span> <span class="n">stream_enable_acks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">add_to_buffer</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.through"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.through">[docs]</a>    <span class="k">def</span> <span class="nf">through</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ChannelT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Forward values to in this stream to channel.</span>

<span class="sd">        Send messages received on this stream to another channel,</span>
<span class="sd">        and return a new stream that consumes from that channel.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The messages are forwarded after any processors have been</span>
<span class="sd">            applied.</span>

<span class="sd">        Example:</span>
<span class="sd">            .. sourcecode:: python</span>

<span class="sd">                topic = app.topic(&#39;foo&#39;)</span>

<span class="sd">                @app.agent(topic)</span>
<span class="sd">                async def mytask(stream):</span>
<span class="sd">                    async for value in stream.through(app.topic(&#39;bar&#39;)):</span>
<span class="sd">                        # value was first received in topic &#39;foo&#39;,</span>
<span class="sd">                        # then forwarded and consumed from topic &#39;bar&#39;</span>
<span class="sd">                        print(value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="c1"># if agent restart we reuse the same stream object</span>
            <span class="c1"># which already have done the stream.through()</span>
            <span class="c1"># so on iteration we set the finalized flag</span>
            <span class="c1"># and make this through() a noop.</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concurrency_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImproperlyConfigured</span><span class="p">(</span>
                <span class="s2">&quot;Agent with concurrency&gt;1 cannot use stream.through!&quot;</span>
            <span class="p">)</span>
        <span class="c1"># ridiculous mypy</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">channelchannel</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">derive_topic</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">channelchannel</span> <span class="o">=</span> <span class="n">channel</span>

        <span class="n">channel_it</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="n">channelchannel</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImproperlyConfigured</span><span class="p">(</span><span class="s2">&quot;Stream is already using group_by/through&quot;</span><span class="p">)</span>
        <span class="n">through</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chain</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="n">channel_it</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">maybe_forward</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">channelchannel</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">forward</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_passive</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="n">channel_it</span><span class="p">),</span> <span class="n">declare</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">through</span></div>

    <span class="k">def</span> <span class="nf">_enable_passive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">declare</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_passive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_passive</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_future</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_passive_drainer</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">declare</span><span class="p">))</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_passive_drainer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">ChannelT</span><span class="p">,</span> <span class="n">declare</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">declare</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">maybe_declare</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_passive_started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">async</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
                    <span class="o">...</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># forward the exception to the final destination channel,</span>
                <span class="c1"># e.g. in through/group_by/etc.</span>
                <span class="k">await</span> <span class="n">channel</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_channel_stop_iteration</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_passive</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_channel_stop_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">on_stop_iteration</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">on_stop_iteration</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">on_stop_iteration</span><span class="p">()</span>

<div class="viewcode-block" id="Stream.echo"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.echo">[docs]</a>    <span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">channels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ChannelT</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Forward values to one or more channels.</span>

<span class="sd">        Unlike :meth:`through`, we don&#39;t consume from these channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_channels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">derive_topic</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">channels</span>
        <span class="p">]</span>

        <span class="k">async</span> <span class="k">def</span> <span class="nf">echoing</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
                <span class="p">[</span><span class="n">maybe_forward</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">_channels</span><span class="p">],</span>
                <span class="n">return_when</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">ALL_COMPLETED</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">echoing</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Stream.group_by"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.group_by">[docs]</a>    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">GroupByKeyArg</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">topic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TopicT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create new stream that repartitions the stream using a new key.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            key: The key argument decides how the new key is generated,</span>
<span class="sd">                it can be a field descriptor, a callable, or an async</span>
<span class="sd">                callable.</span>

<span class="sd">                Note: The ``name`` argument must be provided if the key</span>
<span class="sd">                    argument is a callable.</span>

<span class="sd">            name: Suffix to use for repartitioned topics.</span>
<span class="sd">                This argument is required if `key` is a callable.</span>

<span class="sd">        Examples:</span>
<span class="sd">            Using a field descriptor to use a field in the event as the new</span>
<span class="sd">            key:</span>

<span class="sd">            .. sourcecode:: python</span>

<span class="sd">                s = withdrawals_topic.stream()</span>
<span class="sd">                # values in this stream are of type Withdrawal</span>
<span class="sd">                async for event in s.group_by(Withdrawal.account_id):</span>
<span class="sd">                    ...</span>

<span class="sd">            Using an async callable to extract a new key:</span>

<span class="sd">            .. sourcecode:: python</span>

<span class="sd">                s = withdrawals_topic.stream()</span>

<span class="sd">                async def get_key(withdrawal):</span>
<span class="sd">                    return await aiohttp.get(</span>
<span class="sd">                        f&#39;http://e.com/resolve_account/{withdrawal.account_id}&#39;)</span>

<span class="sd">                async for event in s.group_by(get_key):</span>
<span class="sd">                    ...</span>

<span class="sd">            Using a regular callable to extract a new key:</span>

<span class="sd">            .. sourcecode:: python</span>

<span class="sd">                s = withdrawals_topic.stream()</span>

<span class="sd">                def get_key(withdrawal):</span>
<span class="sd">                    return withdrawal.account_id.upper()</span>

<span class="sd">                async for event in s.group_by(get_key):</span>
<span class="sd">                    ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="c1"># see note in self.through()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">channel</span><span class="p">:</span> <span class="n">ChannelT</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concurrency_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImproperlyConfigured</span><span class="p">(</span>
                <span class="s2">&quot;Agent with concurrency&gt;1 cannot use stream.group_by!&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">FieldDescriptorT</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">ident</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;group_by with callback must set name=topic_suffix&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">topic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">topic</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cast</span><span class="p">(</span><span class="n">TopicT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span><span class="o">.</span><span class="n">has_prefix</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;-</span><span class="si">{name}</span><span class="s2">-repartition&quot;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">partitions</span> <span class="k">if</span> <span class="n">partitions</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">topic_partitions</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span><span class="o">.</span><span class="n">derive</span><span class="p">(</span>
                <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span> <span class="n">partitions</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">internal</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="n">format_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_key</span>

        <span class="n">channel_it</span> <span class="o">=</span> <span class="n">aiter</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImproperlyConfigured</span><span class="p">(</span><span class="s2">&quot;Stream already uses group_by/through&quot;</span><span class="p">)</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chain</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="n">channel_it</span><span class="p">)</span>

        <span class="k">async</span> <span class="k">def</span> <span class="nf">repartition</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span>
            <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot repartition stream with non-topic channel&quot;</span><span class="p">)</span>
            <span class="n">new_key</span> <span class="o">=</span> <span class="k">await</span> <span class="n">format_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">await</span> <span class="n">event</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">new_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">repartition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_passive</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="n">channel_it</span><span class="p">),</span> <span class="n">declare</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped</span></div>

<div class="viewcode-block" id="Stream.filter"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">:</span> <span class="n">Processor</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Filter values from stream using callback.</span>

<span class="sd">        The callback may be a traditional function, lambda function,</span>
<span class="sd">        or an `async def` function.</span>

<span class="sd">        This method is useful for filtering events before repartitioning</span>
<span class="sd">        a stream.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; async for v in stream.filter(lambda: v &gt; 1000).group_by(...):</span>
<span class="sd">            ...     # do something</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">async</span> <span class="k">def</span> <span class="nf">on_value</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="k">await</span> <span class="n">maybe_async</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">Skip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_processor</span><span class="p">(</span><span class="n">on_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_format_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">GroupByKeyArg</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T_contra</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">FieldDescriptorT</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">ModelT</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">maybe_async</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">key</span><span class="p">)(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Error in grouping key : </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">exc</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">Skip</span><span class="p">()</span> <span class="kn">from</span> <span class="nn">exc</span>

<div class="viewcode-block" id="Stream.derive_topic"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.derive_topic">[docs]</a>    <span class="k">def</span> <span class="nf">derive_topic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">schema</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SchemaT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">key_type</span><span class="p">:</span> <span class="n">ModelArg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_type</span><span class="p">:</span> <span class="n">ModelArg</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TopicT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create Topic description derived from the K/V type of this stream.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            name: Topic name.</span>

<span class="sd">            key_type: Specific key type to use for this topic.</span>
<span class="sd">                If not set, the key type of this stream will be used.</span>
<span class="sd">            value_type: Specific value type to use for this topic.</span>
<span class="sd">                If not set, the value type of this stream will be used.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the stream channel is not a topic.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">,</span> <span class="n">TopicT</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">TopicT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span><span class="o">.</span><span class="n">derive_topic</span><span class="p">(</span>
                <span class="n">topics</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                <span class="n">key_type</span><span class="o">=</span><span class="n">key_type</span><span class="p">,</span>
                <span class="n">value_type</span><span class="o">=</span><span class="n">value_type</span><span class="p">,</span>
                <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
                <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot derive topic from non-topic channel.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.throw"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.throw">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">throw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="ne">BaseException</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Send exception to stream iteration.&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stream.combine"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.combine">[docs]</a>    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">:</span> <span class="n">JoinableT</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combine streams and tables into joined stream.&quot;&quot;&quot;</span>
        <span class="c1"># A combined stream is composed of multiple streams that</span>
        <span class="c1"># all share the same outbox.</span>
        <span class="c1"># The resulting stream&#39;s `on_merge` callback can be used to</span>
        <span class="c1"># process values from all the combined streams, and e.g.</span>
        <span class="c1"># joins uses this to consolidate multiple values into one.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="c1"># see note in self.through()</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chain</span><span class="p">(</span><span class="n">combined</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">combined</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">combined</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">contribute_to_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream</span></div>

<div class="viewcode-block" id="Stream.contribute_to_stream"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.contribute_to_stream">[docs]</a>    <span class="k">def</span> <span class="nf">contribute_to_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="n">StreamT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add stream as node in joined stream.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outbox</span> <span class="o">=</span> <span class="n">active</span><span class="o">.</span><span class="n">outbox</span></div>

<div class="viewcode-block" id="Stream.remove_from_stream"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.remove_from_stream">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">remove_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">:</span> <span class="n">StreamT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Remove as node in a joined stream.&quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stream.join"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldDescriptorT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create stream where events are joined.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">joins</span><span class="o">.</span><span class="n">RightJoin</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.left_join"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.left_join">[docs]</a>    <span class="k">def</span> <span class="nf">left_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldDescriptorT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create stream where events are joined by LEFT JOIN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">joins</span><span class="o">.</span><span class="n">LeftJoin</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.inner_join"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.inner_join">[docs]</a>    <span class="k">def</span> <span class="nf">inner_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldDescriptorT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create stream where events are joined by INNER JOIN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">joins</span><span class="o">.</span><span class="n">InnerJoin</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.outer_join"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.outer_join">[docs]</a>    <span class="k">def</span> <span class="nf">outer_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fields</span><span class="p">:</span> <span class="n">FieldDescriptorT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create stream where events are joined by OUTER JOIN.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join</span><span class="p">(</span><span class="n">joins</span><span class="o">.</span><span class="n">OuterJoin</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="n">fields</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join_strategy</span><span class="p">:</span> <span class="n">JoinT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">StreamT</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">join_strategy</span><span class="o">=</span><span class="n">join_strategy</span><span class="p">)</span>

<div class="viewcode-block" id="Stream.on_merge"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.on_merge">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Signal called when an event is to be joined.&quot;&quot;&quot;</span>
        <span class="c1"># TODO for joining streams</span>
        <span class="c1"># The join strategy.process method can return None</span>
        <span class="c1"># to eat the value, and on the next event create a merged</span>
        <span class="c1"># event out of the previous event and new event.</span>
        <span class="n">join_strategy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strategy</span>
        <span class="k">if</span> <span class="n">join_strategy</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">join_strategy</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Stream.on_start"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.on_start">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Signal called when the stream starts.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_start</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_start</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_passive</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_passive_started</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stream.stop"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.stop">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Stop this stream.&quot;&quot;&quot;</span>
        <span class="c1"># Stop all related streams (created by .through/.group_by/etc.)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">Stream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_root_stream</span><span class="p">())</span><span class="o">.</span><span class="n">_iter_ll_forwards</span><span class="p">():</span>
            <span class="k">await</span> <span class="n">Service</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="n">Service</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stream.on_stop"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.on_stop">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_stop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Signal that the stream is stopping.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_passive</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_passive_started</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">table_or_stream</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">table_or_stream</span><span class="o">.</span><span class="n">remove_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Streams are asynchronous: use `async for`&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T_co</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">if</span> <span class="n">_CStreamIterator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_aiter</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_py_aiter</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_c_aiter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T_co</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span><span class="s2">&quot;Using Cython optimized __aiter__&quot;</span><span class="p">)</span>
        <span class="n">skipped_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipped_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">started_by_aiter</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_start</span><span class="p">()</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">_CStreamIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_stop</span><span class="p">:</span>
                <span class="n">do_ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">sensor_state</span> <span class="o">=</span> <span class="k">await</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>  <span class="c1"># noqa: B305</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">skipped_value</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events_total</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">value</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="n">event</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">do_ack</span><span class="p">,</span> <span class="n">sensor_state</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">StopAsyncIteration</span><span class="p">:</span>
            <span class="c1"># We are not allowed to propagate StopAsyncIteration in __aiter__</span>
            <span class="c1"># (if we do, it&#39;ll be converted to RuntimeError by CPython).</span>
            <span class="c1"># It can be raised when streaming over a list:</span>
            <span class="c1">#    async for value in app.stream([1, 2, 3, 4]):</span>
            <span class="c1">#       ...</span>
            <span class="c1"># To support that, we just return here and that will stop</span>
            <span class="c1"># the iteration.</span>
            <span class="k">return</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_channel_stop_iteration</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">started_by_aiter</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">service_reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_current_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EventT</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_current_event</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_current_event</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="o">=</span> <span class="n">event</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_py_aiter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T_co</span><span class="p">]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">started_by_aiter</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">maybe_start</span><span class="p">()</span>
        <span class="n">on_merge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_merge</span>
        <span class="n">on_stream_event_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_stream_event_out</span>
        <span class="n">on_message_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_message_out</span>

        <span class="c1"># get from channel</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelT</span><span class="p">):</span>
            <span class="n">chan_is_channel</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">chan</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ChannelT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>
            <span class="n">chan_queue</span> <span class="o">=</span> <span class="n">chan</span><span class="o">.</span><span class="n">queue</span>
            <span class="n">chan_queue_empty</span> <span class="o">=</span> <span class="n">chan_queue</span><span class="o">.</span><span class="n">empty</span>
            <span class="n">chan_errors</span> <span class="o">=</span> <span class="n">chan_queue</span><span class="o">.</span><span class="n">_errors</span>
            <span class="n">chan_quick_get</span> <span class="o">=</span> <span class="n">chan_queue</span><span class="o">.</span><span class="n">get_nowait</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chan_is_channel</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">chan_queue</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ThrowableQueue</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">chan_queue_empty</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">chan_errors</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Deque</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">chan_quick_get</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">chan_slow_get</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="fm">__anext__</span>
        <span class="c1"># Topic description -&gt; processors</span>
        <span class="n">processors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_processors</span>
        <span class="c1"># Sensor: on_stream_event_in</span>
        <span class="n">on_stream_event_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_stream_event_in</span>

        <span class="c1"># localize global variables</span>
        <span class="n">create_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span>
        <span class="n">_maybe_async</span> <span class="o">=</span> <span class="n">maybe_async</span>
        <span class="n">event_cls</span> <span class="o">=</span> <span class="n">EventT</span>
        <span class="n">_current_event_contextvar</span> <span class="o">=</span> <span class="n">_current_event</span>

        <span class="n">consumer</span><span class="p">:</span> <span class="n">ConsumerT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">consumer</span>
        <span class="n">unacked</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">Message</span><span class="p">]</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="n">unacked</span>
        <span class="n">add_unacked</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Message</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">unacked</span><span class="o">.</span><span class="n">add</span>
        <span class="n">acking_topics</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">topics</span><span class="o">.</span><span class="n">acking_topics</span>
        <span class="n">on_message_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_message_in</span>
        <span class="n">sleep</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">trace</span>
        <span class="n">_shortlabel</span> <span class="o">=</span> <span class="n">shortlabel</span>
        <span class="n">sensor_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">skipped_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipped_value</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">should_stop</span><span class="p">:</span>
                <span class="n">event</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">do_ack</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_acks</span>  <span class="c1"># set to False to not ack event.</span>
                <span class="c1"># wait for next message</span>
                <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># we iterate until on_merge gives value.</span>
                <span class="k">while</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">event</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">await</span> <span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># get message from channel</span>
                    <span class="c1"># This inlines ThrowableQueue.get for performance:</span>
                    <span class="c1"># We selectively call `await Q.put`/`Q.put_nowait`,</span>
                    <span class="c1"># and prefer the latter if the queue is non-empty.</span>
                    <span class="n">channel_value</span><span class="p">:</span> <span class="n">Any</span>
                    <span class="k">if</span> <span class="n">chan_is_channel</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">chan_errors</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="n">chan_errors</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">chan_queue_empty</span><span class="p">():</span>
                            <span class="n">channel_value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">chan_slow_get</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">channel_value</span> <span class="o">=</span> <span class="n">chan_quick_get</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># chan is an AsyncIterable</span>
                        <span class="n">channel_value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">chan_slow_get</span><span class="p">()</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">channel_value</span><span class="p">,</span> <span class="n">event_cls</span><span class="p">):</span>
                        <span class="n">event</span> <span class="o">=</span> <span class="n">channel_value</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span>
                        <span class="n">topic</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">topic</span>
                        <span class="n">tp</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">tp</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">offset</span>

                        <span class="k">if</span> <span class="p">(</span>
                            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">flow_control</span><span class="o">.</span><span class="n">is_active</span><span class="p">()</span>
                            <span class="ow">or</span> <span class="n">message</span><span class="o">.</span><span class="n">generation_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">consumer_generation_id</span>
                        <span class="p">):</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">skipped_value</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">dev</span><span class="p">(</span>
                                <span class="s2">&quot;Skipping message </span><span class="si">%r</span><span class="s2"> with generation_id </span><span class="si">%r</span><span class="s2"> because &quot;</span>
                                <span class="s2">&quot;app generation_id is </span><span class="si">%r</span><span class="s2"> flow_control.is_active </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                                <span class="n">message</span><span class="p">,</span>
                                <span class="n">message</span><span class="o">.</span><span class="n">generation_id</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">consumer_generation_id</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">flow_control</span><span class="o">.</span><span class="n">is_active</span><span class="p">(),</span>
                            <span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">topic</span> <span class="ow">in</span> <span class="n">acking_topics</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">message</span><span class="o">.</span><span class="n">tracked</span><span class="p">:</span>
                            <span class="n">message</span><span class="o">.</span><span class="n">tracked</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="c1"># This inlines Consumer.track_message(message)</span>
                            <span class="n">add_unacked</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
                            <span class="n">on_message_in</span><span class="p">(</span><span class="n">message</span><span class="o">.</span><span class="n">tp</span><span class="p">,</span> <span class="n">message</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
                            <span class="c1"># XXX ugh this should be in the consumer somehow</span>

                        <span class="c1"># call Sensors</span>
                        <span class="n">sensor_state</span> <span class="o">=</span> <span class="n">on_stream_event_in</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>

                        <span class="c1"># set task-local current_event</span>
                        <span class="n">_current_event_contextvar</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">create_ref</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
                        <span class="c1"># set Stream._current_event</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="o">=</span> <span class="n">event</span>

                        <span class="c1"># Stream yields Event.value</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">channel_value</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">sensor_state</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1"># reduce using processors</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">processor</span> <span class="ow">in</span> <span class="n">processors</span><span class="p">:</span>
                            <span class="k">with</span> <span class="n">trace</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;processor-{_shortlabel(processor)}&quot;</span><span class="p">):</span>
                                <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">_maybe_async</span><span class="p">(</span><span class="n">processor</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="k">await</span> <span class="n">on_merge</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">Skip</span><span class="p">:</span>
                        <span class="c1"># We want to ack the filtered message</span>
                        <span class="c1"># otherwise the lag would increase</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">skipped_value</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">skipped_value</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events_total</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">value</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_event</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># We want to ack the filtered out message</span>
                    <span class="c1"># otherwise the lag would increase</span>
                    <span class="k">if</span> <span class="n">event</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">do_ack</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">skipped_value</span><span class="p">):</span>
                        <span class="c1"># This inlines self.ack</span>
                        <span class="n">last_stream_to_ack</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">ack</span><span class="p">()</span>
                        <span class="n">message</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span>
                        <span class="n">tp</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">tp</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span><span class="o">.</span><span class="n">offset</span>
                        <span class="n">on_stream_event_out</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">sensor_state</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">last_stream_to_ack</span><span class="p">:</span>
                            <span class="n">on_message_out</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">StopAsyncIteration</span><span class="p">:</span>
            <span class="c1"># We are not allowed to propagate StopAsyncIteration in __aiter__</span>
            <span class="c1"># (if we do, it&#39;ll be converted to RuntimeError by CPython).</span>
            <span class="c1"># It can be raised when streaming over a list:</span>
            <span class="c1">#    async for value in app.stream([1, 2, 3, 4]):</span>
            <span class="c1">#       ...</span>
            <span class="c1"># To support that, we just return here and that will stop</span>
            <span class="c1"># the iteration.</span>
            <span class="k">return</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_channel_stop_iteration</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">started_by_aiter</span><span class="p">:</span>
                <span class="c1"># if `async for` called Stream.start()</span>
                <span class="c1"># we need to stop it before ending iteration.</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
                <span class="c1"># reset to allow calling .start again on next `async for`</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">service_reset</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="o">...</span>

<div class="viewcode-block" id="Stream.ack"><a class="viewcode-back" href="../../reference/faust.streams.html#faust.Stream.ack">[docs]</a>    <span class="k">async</span> <span class="k">def</span> <span class="nf">ack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">EventT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Ack event.</span>

<span class="sd">        This will decrease the reference count of the event message by one,</span>
<span class="sd">        and when the reference count reaches zero, the worker will</span>
<span class="sd">        commit the offset so that the message will not be seen by a worker</span>
<span class="sd">        again.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            event: Event to ack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># WARNING: This function is duplicated in __aiter__</span>
        <span class="n">last_stream_to_ack</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">ack</span><span class="p">()</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">tp</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">message</span><span class="o">.</span><span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_stream_event_out</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">last_stream_to_ack</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_on_message_out</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">last_stream_to_ack</span></div>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_repr_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reprlib</span><span class="o">.</span><span class="n">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reprlib</span><span class="o">.</span><span class="n">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return description of stream, used in graphs and logs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;{type(self).__name__}: {self._repr_channel()}&quot;</span>

    <span class="k">def</span> <span class="nf">_repr_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reprlib</span><span class="o">.</span><span class="n">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shortlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return short description of stream.&quot;&quot;&quot;</span>
        <span class="c1"># used for shortlabel(stream), which is used by statsd to generate ids</span>
        <span class="c1"># note: str(channel) returns topic name when it&#39;s a topic, so</span>
        <span class="c1"># this will be:</span>
        <span class="c1">#    &quot;Channel: &lt;ANON&gt;&quot;, for channel or</span>
        <span class="c1">#    &quot;Topic: withdrawals&quot;, for a topic.</span>
        <span class="c1"># statsd then uses that as part of the id.</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;Stream: {self._human_channel()}&quot;</span>

    <span class="k">def</span> <span class="nf">_human_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">_human_channel</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">combined</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;{type(self.channel).__name__}: </span><span class="si">{self.channel}</span><span class="s2">&quot;</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">Faust</a></h1>



<p class="blurb">A library for building streaming applications in Python.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=robinhood&repo=faust&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/robinhood/faust">
    <img
        alt="https://secure.travis-ci.org/robinhood/faust.svg?branch=master"
        src="https://secure.travis-ci.org/robinhood/faust.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introducing Faust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../playbooks/index.html">Playbooks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/index.html">User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Frequently Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../developerguide/index.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history/index.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017-2020, 2021-2022 Community, Robinhood Markets, Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/robinhood/faust" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>